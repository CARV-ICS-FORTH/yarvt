commit 9991e272fd14e18f919e71b21a6008f0644af11a
Author: Nick Kossifidis <mick@ics.forth.gr>
Date:   Sun Mar 3 05:42:10 2024 +0200

    Add eupilot-vec machine

diff --git a/configs/devices/riscv64-softmmu/default.mak b/configs/devices/riscv64-softmmu/default.mak
index bc69301..e332fb0 100644
--- a/configs/devices/riscv64-softmmu/default.mak
+++ b/configs/devices/riscv64-softmmu/default.mak
@@ -14,3 +14,4 @@ CONFIG_SIFIVE_U=y
 CONFIG_RISCV_VIRT=y
 CONFIG_MICROCHIP_PFSOC=y
 CONFIG_SHAKTI_C=y
+CONFIG_SDV3=y
diff --git a/hw/intc/sifive_plic.c b/hw/intc/sifive_plic.c
index 5522ede..3df50e4 100644
--- a/hw/intc/sifive_plic.c
+++ b/hw/intc/sifive_plic.c
@@ -348,7 +348,11 @@ static void parse_hart_config(SiFivePLICState *plic)
 static void sifive_plic_irq_request(void *opaque, int irq, int level)
 {
     SiFivePLICState *s = opaque;
-
+    /* Don't allow sources/gateways to clear the pending bit,
+     * the pending bit should only be cleared when interrupt is
+     * claimed by the host. */
+    if (level <= 0)
+        return;
     sifive_plic_set_pending(s, irq, level > 0);
     sifive_plic_update(s);
 }
diff --git a/hw/riscv/Kconfig b/hw/riscv/Kconfig
index b6a5eb4..046205a 100644
--- a/hw/riscv/Kconfig
+++ b/hw/riscv/Kconfig
@@ -46,6 +46,14 @@ config RISCV_VIRT
     select PLATFORM_BUS
     select ACPI
 
+config SDV3
+    bool
+    select PFLASH_CFI01
+    select SERIAL
+    select RISCV_ACLINT
+    select SIFIVE_PLIC
+    select XILINX_ETHLITE
+
 config SHAKTI_C
     bool
     select RISCV_ACLINT
diff --git a/hw/riscv/meson.build b/hw/riscv/meson.build
index 2f7ee81..ce032bd 100644
--- a/hw/riscv/meson.build
+++ b/hw/riscv/meson.build
@@ -4,6 +4,7 @@ riscv_ss.add(when: 'CONFIG_RISCV_NUMA', if_true: files('numa.c'))
 riscv_ss.add(files('riscv_hart.c'))
 riscv_ss.add(when: 'CONFIG_OPENTITAN', if_true: files('opentitan.c'))
 riscv_ss.add(when: 'CONFIG_RISCV_VIRT', if_true: files('virt.c'))
+riscv_ss.add(when: 'CONFIG_SDV3', if_true: files('sdv3.c'))
 riscv_ss.add(when: 'CONFIG_SHAKTI_C', if_true: files('shakti_c.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_E', if_true: files('sifive_e.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_U', if_true: files('sifive_u.c'))
diff --git a/hw/riscv/sdv3.c b/hw/riscv/sdv3.c
new file mode 100644
index 0000000..2b142d0
--- /dev/null
+++ b/hw/riscv/sdv3.c
@@ -0,0 +1,630 @@
+/*
+ * QEMU SDV3 board
+ *
+ * Copyright (c) 2023 ICS/FORTH.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "qemu/error-report.h"
+#include "qemu/guest-random.h"
+#include "qapi/error.h"
+#include "hw/boards.h"
+#include "hw/loader.h"
+#include "hw/sysbus.h"
+#include "hw/qdev-properties.h"
+#include "hw/char/serial.h"
+#include "target/riscv/cpu.h"
+#include "hw/core/sysbus-fdt.h"
+#include "target/riscv/pmu.h"
+#include "hw/riscv/riscv_hart.h"
+#include "hw/riscv/boot.h"
+#include "hw/intc/riscv_aclint.h"
+#include "hw/intc/sifive_plic.h"
+#include "hw/misc/sifive_test.h"
+#include "hw/platform-bus.h"
+#include "chardev/char.h"
+#include "sysemu/device_tree.h"
+#include "sysemu/sysemu.h"
+#include "qapi/qapi-visit-common.h"
+#include "net/net.h"
+#include "hw/block/flash.h"
+
+/* SoC Properties */
+#define SDV3_CPUS_MAX			4
+#define	SDV3_TIMEBASE_FREQ		25000000
+#define SDV3_CLOCK_FREQ			50000000
+#define SDV3_PLIC_NUM_SOURCES		20
+#define SDV3_PLIC_NUM_PRIORITIES	7
+
+/* Memory/Device regions */
+enum {
+	SDV3_DEBUG,
+	SDV3_BROM,	/* Used by QEMU to place the reset vector (tiny bootrom) */
+	SDV3_TEST,	/* Doesn't exist in hw, used for reboot/halt */
+	SDV3_CLINT,
+	SDV3_PLIC,
+	SDV3_UART,
+	SDV3_EMACLITE,
+	SDV3_DMAETH,
+	SDV3_FLASH,	/* Doesn't exist in hw, we use it for testing bare metal apps on qemu */
+	SDV3_DRAM
+};
+
+/* IRQs */
+enum {
+	SDV3_UART_IRQ		= 1,
+	SDV3_EMACLITE_IRQ	= 2,
+	SDV3_DMAETH_TX_IRQ	= 3,
+	SDV3_DMAETH_RX_IRQ	= 4
+};
+
+/* Helper macros */
+#define TYPE_RISCV_SDV3_MACHINE MACHINE_TYPE_NAME("eupilot-vec")
+
+#define PFLASH_SECTOR_SIZE	(256 * KiB)
+#define PLIC_PRIORITY_BASE	0x00
+#define PLIC_PENDING_BASE	0x1000
+#define PLIC_ENABLE_BASE	0x2000
+#define PLIC_ENABLE_STRIDE	0x80
+#define PLIC_CONTEXT_BASE	0x200000
+#define PLIC_CONTEXT_STRIDE	0x1000
+#define PLIC_SIZE(__num_context) \
+    (PLIC_CONTEXT_BASE + (__num_context) * PLIC_CONTEXT_STRIDE)
+
+/* Machine state */
+struct Sdv3State {
+	/* Private (so that we can cast this to MachineState) */
+	MachineState parent;
+
+	/* Public */
+	Notifier machine_done;
+	RISCVHartArrayState cpus;
+	DeviceState *plic;
+	PFlashCFI01 *pflash;
+	int fdt_size;
+};
+
+typedef struct Sdv3State Sdv3State;
+
+#define SDV3_MACHINE(obj) \
+    OBJECT_CHECK(Sdv3State, (obj), TYPE_RISCV_SDV3_MACHINE)
+
+/* Memory map */
+static const MemMapEntry sdv3_memmap[] = {
+	[SDV3_DEBUG]	= { 0x0,		0x100 },
+	[SDV3_BROM]	= { 0x1000,		0x1000 },
+	[SDV3_TEST]	= { 0x100000,		0x1000 },
+	[SDV3_CLINT]	= { 0x2000000,		0x10000 },
+	[SDV3_PLIC]	= { 0xc000000,		PLIC_SIZE(SDV3_CPUS_MAX * 2) },
+	[SDV3_UART]	= { 0x40010000000,	0x1000 },
+	[SDV3_EMACLITE]	= { 0x40011000000,	0x3000 },
+	[SDV3_DMAETH]	= { 0x40011010000,	0x1000 },
+	[SDV3_FLASH]	= { 0x800000000000,	0x200000 },
+	[SDV3_DRAM]	= { 0x800000400000,	0x0 },
+};
+
+static void create_fdt_cpus(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	int hart_count = st->cpus.num_harts;
+	int i = 0;
+	char *cpu_name;
+	char *isa_string;
+	char *intc_name;
+
+	qemu_fdt_add_subnode(ms->fdt, "/cpus");
+	qemu_fdt_setprop_cell(ms->fdt, "/cpus", "timebase-frequency", SDV3_TIMEBASE_FREQ);
+	qemu_fdt_setprop_cell(ms->fdt, "/cpus", "#address-cells", 0x1);
+	qemu_fdt_setprop_cell(ms->fdt, "/cpus", "#size-cells", 0x0);
+
+	for (i = 0; i < hart_count; i++) {
+		RISCVCPU *cpu_ptr = &st->cpus.harts[i];
+
+		/* Populate /cpuX */
+		cpu_name = g_strdup_printf("/cpus/cpu@%d", st->cpus.hartid_base + i);
+		qemu_fdt_add_subnode(ms->fdt, cpu_name);
+		qemu_fdt_setprop_string(ms->fdt, cpu_name, "device_type", "cpu");
+		qemu_fdt_setprop_string(ms->fdt, cpu_name, "compatible", "riscv");
+		qemu_fdt_setprop_cell(ms->fdt, cpu_name, "reg", st->cpus.hartid_base + i);
+
+		isa_string = riscv_isa_string(cpu_ptr);
+		qemu_fdt_setprop_string(ms->fdt, cpu_name, "riscv,isa", isa_string);
+		g_free(isa_string);
+
+		qemu_fdt_setprop_string(ms->fdt, cpu_name, "mmu-type", "riscv,sv48");
+		qemu_fdt_setprop_string(ms->fdt, cpu_name, "status", "okay");
+
+		/* Populate it's local interrupt controller */
+		intc_name = g_strdup_printf("%s/interrupt-controller", cpu_name);
+		qemu_fdt_add_subnode(ms->fdt, intc_name);
+		qemu_fdt_setprop_cell(ms->fdt, intc_name, "#interrupt-cells", 1);
+		qemu_fdt_setprop(ms->fdt, intc_name, "interrupt-controller", NULL, 0);
+		qemu_fdt_setprop_string(ms->fdt, intc_name, "compatible", "riscv,cpu-intc");
+		qemu_fdt_setprop_cell(ms->fdt, intc_name, "phandle", i + 1);
+		g_free(intc_name);
+
+		g_free(cpu_name);
+	}
+}
+
+static void create_fdt_mem(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	char *mem_name;
+	uint64_t addr = sdv3_memmap[SDV3_DRAM].base;
+	uint64_t size = ms->ram_size;
+
+	mem_name = g_strdup_printf("/memory@%" PRIx64, addr);
+	qemu_fdt_add_subnode(ms->fdt, mem_name);
+	qemu_fdt_setprop_string(ms->fdt, mem_name, "device_type", "memory");
+	qemu_fdt_setprop_cells(ms->fdt, mem_name, "reg", addr >> 32, addr, size >> 32, size);
+	g_free(mem_name);
+}
+
+static void create_fdt_flash(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	uint64_t flash_addr = sdv3_memmap[SDV3_FLASH].base;
+	uint64_t flash_size = sdv3_memmap[SDV3_FLASH].size;
+	char *flash_name;
+
+	flash_name = g_strdup_printf("/flash@%" PRIx64, flash_addr);
+	qemu_fdt_add_subnode(ms->fdt, flash_name);
+	qemu_fdt_setprop_string(ms->fdt, flash_name, "compatible", "cfi-flash");
+	qemu_fdt_setprop_cells(ms->fdt, flash_name, "reg",
+				     flash_addr >> 32, flash_addr,
+				     flash_size >> 32, flash_size);
+	qemu_fdt_setprop_cell(ms->fdt, flash_name, "bank-width", 4);
+	g_free(flash_name);
+}
+
+static void create_fdt_pmu(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	char *pmu_name;
+	RISCVCPU hart = st->cpus.harts[0];
+
+	pmu_name = g_strdup_printf("/pmu");
+	qemu_fdt_add_subnode(ms->fdt, pmu_name);
+	qemu_fdt_setprop_string(ms->fdt, pmu_name, "compatible", "riscv,pmu");
+	riscv_pmu_generate_fdt_node(ms->fdt, hart.pmu_avail_ctrs, pmu_name);
+	g_free(pmu_name);
+}
+
+static void create_fdt_clint(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	uint64_t clint_addr = sdv3_memmap[SDV3_CLINT].base;
+	uint64_t clint_size = sdv3_memmap[SDV3_CLINT].size;
+	char *clint_name;
+	uint32_t *clint_cells;
+	int hart_count = st->cpus.num_harts;
+	int i = 0;
+
+	clint_name = g_strdup_printf("/soc/clint@%" PRIx64, clint_addr);
+	qemu_fdt_add_subnode(ms->fdt, clint_name);
+	qemu_fdt_setprop_string(ms->fdt, clint_name, "reg-names", "control");
+	qemu_fdt_setprop_string(ms->fdt, clint_name, "compatible", "riscv,clint0");
+	qemu_fdt_setprop_cells(ms->fdt, clint_name, "reg", clint_addr >> 32, clint_addr,
+			       clint_size >> 32, clint_size);
+
+	clint_cells = g_new0(uint32_t, hart_count * 4);
+	/* Note: cpuX/intc has phandle = X + 1, check out create_fdt_cpus() */
+	for (i = 0; i < hart_count; i++) {
+		clint_cells[i * 4 + 0] = cpu_to_be32(i + 1);
+		clint_cells[i * 4 + 1] = cpu_to_be32(IRQ_M_SOFT);
+		clint_cells[i * 4 + 2] = cpu_to_be32(i + 1);
+		clint_cells[i * 4 + 3] = cpu_to_be32(IRQ_M_TIMER);
+	}
+	qemu_fdt_setprop(ms->fdt, clint_name, "interrupts-extended", clint_cells,
+			 hart_count * sizeof(uint32_t) * 4);
+	g_free(clint_cells);
+	g_free(clint_name);
+}
+
+static void create_fdt_plic(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	uint64_t plic_addr = sdv3_memmap[SDV3_PLIC].base;
+	uint64_t plic_size = sdv3_memmap[SDV3_PLIC].size;
+	char *plic_name;
+	uint32_t *plic_cells;
+	int hart_count = st->cpus.num_harts;
+	/* Note: one phandle for each cpuX/intc and plic is afterwards */
+	uint32_t plic_phandle = hart_count + 1;
+	int i = 0;
+
+	plic_name = g_strdup_printf("/soc/plic@%" PRIx64, plic_addr);
+	qemu_fdt_add_subnode(ms->fdt, plic_name);
+	qemu_fdt_setprop_string(ms->fdt, plic_name, "compatible", "riscv,plic0");
+	qemu_fdt_setprop_cells(ms->fdt, plic_name, "reg", plic_addr >> 32, plic_addr,
+			       plic_size >> 32, plic_size);
+	qemu_fdt_setprop(ms->fdt, plic_name, "interrupt-controller", NULL, 0);
+	qemu_fdt_setprop_cell(ms->fdt, plic_name, "#interrupt-cells", 1);
+	qemu_fdt_setprop_cell(ms->fdt, plic_name, "#address-cells", 0);
+	plic_cells = g_new0(uint32_t, hart_count * 4);
+	/* Note: cpuX/intc has phandle = X + 1, check out create_fdt_cpus() */
+	for (i = 0; i < hart_count; i++) {
+		plic_cells[i * 4 + 0] = cpu_to_be32(i + 1);
+		plic_cells[i * 4 + 1] = cpu_to_be32(IRQ_M_EXT);
+		plic_cells[i * 4 + 2] = cpu_to_be32(i + 1);
+		plic_cells[i * 4 + 3] = cpu_to_be32(IRQ_S_EXT);
+        }
+        qemu_fdt_setprop(ms->fdt, plic_name, "interrupts-extended", plic_cells,
+			 hart_count * sizeof(uint32_t) * 4);
+	g_free(plic_cells);
+
+	qemu_fdt_setprop_cell(ms->fdt, plic_name, "riscv,ndev", SDV3_PLIC_NUM_SOURCES);
+	qemu_fdt_setprop_cell(ms->fdt, plic_name, "phandle", plic_phandle);
+
+	g_free(plic_name);
+}
+
+static void create_fdt_uart(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	uint64_t uart_addr = sdv3_memmap[SDV3_UART].base;
+	uint64_t uart_size = sdv3_memmap[SDV3_UART].size;
+	char *uart_name;
+	int hart_count = st->cpus.num_harts;
+	uint32_t plic_phandle = hart_count + 1;
+
+	uart_name = g_strdup_printf("/soc/uart@%" PRIx64, uart_addr);
+	qemu_fdt_add_subnode(ms->fdt, uart_name);
+	qemu_fdt_setprop_string(ms->fdt, uart_name, "compatible", "ns16550a");
+	qemu_fdt_setprop_cells(ms->fdt, uart_name, "reg", uart_addr >> 32, uart_addr,
+			       uart_size >> 32, uart_size);
+	qemu_fdt_setprop_cell(ms->fdt, uart_name, "clock-frequency", SDV3_CLOCK_FREQ);
+	qemu_fdt_setprop_cell(ms->fdt, uart_name, "current-speed", 115200);
+	qemu_fdt_setprop_cell(ms->fdt, uart_name, "reg-shift", 2);
+	qemu_fdt_setprop_cell(ms->fdt, uart_name, "interrupt-parent", plic_phandle);
+	qemu_fdt_setprop_cell(ms->fdt, uart_name, "interrupts", SDV3_UART_IRQ);
+
+	/* Add stdout-path on /chosen */
+	qemu_fdt_add_subnode(ms->fdt, "/chosen");
+	qemu_fdt_setprop_string(ms->fdt, "/chosen", "stdout-path", uart_name);
+
+	/* Create /aliases/serial0 */
+	qemu_fdt_add_subnode(ms->fdt, "/aliases");
+	qemu_fdt_setprop_string(ms->fdt, "/aliases", "serial0", uart_name);
+
+	g_free(uart_name);
+}
+
+static void create_fdt_emaclite(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	uint64_t emaclite_addr = sdv3_memmap[SDV3_EMACLITE].base;
+	uint64_t emaclite_size = sdv3_memmap[SDV3_EMACLITE].size;
+	char *emaclite_name;
+	char *emaclite_mdio_name;
+	int hart_count = st->cpus.num_harts;
+	uint32_t plic_phandle = hart_count + 1;
+
+	emaclite_name = g_strdup_printf("/soc/emaclite@%" PRIx64, emaclite_addr);
+	qemu_fdt_add_subnode(ms->fdt, emaclite_name);
+	qemu_fdt_setprop_string(ms->fdt, emaclite_name, "compatible", "xlnx,xps-ethernetlite-1.00.a");
+	qemu_fdt_setprop_cells(ms->fdt, emaclite_name, "reg", emaclite_addr >> 32, emaclite_addr,
+			       emaclite_size >> 32, emaclite_size);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "interrupt-parent", plic_phandle);
+	qemu_fdt_setprop_string(ms->fdt, emaclite_name, "interrupt-names", "ip2intc_irpt");
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "interrupts", SDV3_EMACLITE_IRQ);
+
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,duplex", 1);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,include-mdio", 0);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,include-global-buffers", 0);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,include-internal-loopback", 1);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,rx-ping-pong", 1);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,tx-ping-pong", 1);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,s-axi-id-width", 1);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,select-xpm", 1);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_name, "xlnx,use-internal", 0);
+
+	/* Create empty mdio subnode */
+	emaclite_mdio_name = g_strdup_printf("/soc/emaclite@%" PRIx64 "/mdio", emaclite_addr);
+	qemu_fdt_add_subnode(ms->fdt, emaclite_mdio_name);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_mdio_name, "#address-cells", 0x1);
+	qemu_fdt_setprop_cell(ms->fdt, emaclite_mdio_name, "#size-cells", 0x0);
+	g_free(emaclite_mdio_name);
+	
+	/* Create /aliases/ethernet0 */
+	qemu_fdt_setprop_string(ms->fdt, "/aliases", "ethernet0", emaclite_name);
+
+	g_free(emaclite_name);
+}
+
+static void create_fdt_test(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	uint64_t test_addr = sdv3_memmap[SDV3_TEST].base;
+	uint64_t test_size = sdv3_memmap[SDV3_TEST].size;
+	char *name;
+	int hart_count = st->cpus.num_harts;
+	uint32_t test_phandle = hart_count + 2;	/* PLIC's phandle + 1 */
+
+	name = g_strdup_printf("/soc/test@%" PRIx64, test_addr);
+	qemu_fdt_add_subnode(ms->fdt, name);
+	{
+		static const char * const compat[3] = {
+			"sifive,test1", "sifive,test0", "syscon"
+		};
+		qemu_fdt_setprop_string_array(ms->fdt, name, "compatible",
+					(char **)&compat, ARRAY_SIZE(compat));
+	}
+	qemu_fdt_setprop_cells(ms->fdt, name, "reg", test_addr >> 32, test_addr,
+			       test_size >> 32, test_size);
+	qemu_fdt_setprop_cell(ms->fdt, name, "phandle", test_phandle);
+	g_free(name);
+
+	name = g_strdup_printf("/reboot");
+	qemu_fdt_add_subnode(ms->fdt, name);
+	qemu_fdt_setprop_string(ms->fdt, name, "compatible", "syscon-reboot");
+	qemu_fdt_setprop_cell(ms->fdt, name, "regmap", test_phandle);
+	qemu_fdt_setprop_cell(ms->fdt, name, "offset", 0x0);
+	qemu_fdt_setprop_cell(ms->fdt, name, "value", FINISHER_RESET);
+	g_free(name);
+
+	name = g_strdup_printf("/poweroff");
+	qemu_fdt_add_subnode(ms->fdt, name);
+	qemu_fdt_setprop_string(ms->fdt, name, "compatible", "syscon-poweroff");
+	qemu_fdt_setprop_cell(ms->fdt, name, "regmap", test_phandle);
+	qemu_fdt_setprop_cell(ms->fdt, name, "offset", 0x0);
+	qemu_fdt_setprop_cell(ms->fdt, name, "value", FINISHER_PASS);
+	g_free(name);
+}
+
+static void create_fdt(Sdv3State *st)
+{
+	MachineState *ms = MACHINE(st);
+	uint8_t rng_seed[32];
+
+	/* Initialize empty device tree */
+	ms->fdt = create_device_tree(&st->fdt_size);
+	if (!ms->fdt) {
+		error_report("create_device_tree() failed");
+		exit(1);
+	}
+
+	/* Create root node */
+	qemu_fdt_setprop_string(ms->fdt, "/", "model", "eupilot-qemu");
+	qemu_fdt_setprop_string(ms->fdt, "/", "compatible", "eupilot-vec");
+	qemu_fdt_setprop_cell(ms->fdt, "/", "#size-cells", 0x2);
+	qemu_fdt_setprop_cell(ms->fdt, "/", "#address-cells", 0x2);
+
+	/* Populate /cpus */
+	create_fdt_cpus(st);
+
+	/* Populate /memory */
+	create_fdt_mem(st);
+
+	/* Populate /flash */
+	create_fdt_flash(st);
+
+	/* Populate /pmu */
+	create_fdt_pmu(st);
+
+	/* Soc subnode/subtree */
+	qemu_fdt_add_subnode(ms->fdt, "/soc");
+	qemu_fdt_setprop(ms->fdt, "/soc", "ranges", NULL, 0);
+	qemu_fdt_setprop_string(ms->fdt, "/soc", "compatible", "simple-bus");
+	qemu_fdt_setprop_cell(ms->fdt, "/soc", "#size-cells", 0x2);
+	qemu_fdt_setprop_cell(ms->fdt, "/soc", "#address-cells", 0x2);
+
+	/* Populate /soc/clint */
+	create_fdt_clint(st);
+
+	/* Populate /soc/plic */
+	create_fdt_plic(st);
+
+	/* Populate /soc/uart, also creates /chosen/stdout-path and /aliases/serial0 */
+	create_fdt_uart(st);
+
+	/* Populate /soc/emaclite, also creates /aliases/ethernet0 */
+	create_fdt_emaclite(st);
+
+	/* Populate /soc/test, /reboot, /poweroff */
+	create_fdt_test(st);
+
+	/* Pass seed to RNG */
+	qemu_guest_getrandom_nofail(rng_seed, sizeof(rng_seed));
+	qemu_fdt_setprop(ms->fdt, "/chosen", "rng-seed", rng_seed, sizeof(rng_seed));
+}
+
+static void sdv3_machine_done(Notifier *notifier, void *data)
+{
+	Sdv3State *st = container_of(notifier, Sdv3State, machine_done);
+	MachineState *machine = MACHINE(st);
+	uint64_t fdt_load_addr = 0;
+	uint64_t start_addr = sdv3_memmap[SDV3_DRAM].base;
+	const char *firmware_name = riscv_default_firmware_name(&st->cpus);
+	uint64_t firmware_end_addr = 0;
+	uint64_t s_mode_payload_addr = 0;
+	uint64_t kernel_start_addr = 0;
+	BlockBackend *pflash_blk0;
+
+	/* Load firmware to DRAM: if -bios is provided we use that, instead we use the
+	 * built-in OpenSBI, if -bios none is passed then this will do nothing and will return start_addr. */
+	firmware_end_addr = riscv_find_and_load_firmware(machine, firmware_name, start_addr, NULL);
+
+	/* Check if user provided a payload in pflash */
+	pflash_blk0 = pflash_cfi01_get_blk(st->pflash);
+	if (pflash_blk0) {
+		/* We didn't get a firmware, run form pflash instead */
+		if(machine->firmware && !strcmp(machine->firmware, "none")) {
+			start_addr = sdv3_memmap[SDV3_FLASH].base;
+		/* We got a firmware, use it to run pflash as s-mode payload */
+		} else {
+			riscv_setup_firmware_boot(machine);
+			s_mode_payload_addr = sdv3_memmap[SDV3_FLASH].base;
+		}
+	}
+
+	/* Check if user provided a kernel (s-mode payload in elf format) */
+	if (machine->kernel_filename && !s_mode_payload_addr) {
+		kernel_start_addr = riscv_calc_kernel_start_addr(&st->cpus,
+                                                         firmware_end_addr);
+
+		s_mode_payload_addr = riscv_load_kernel(machine, &st->cpus, kernel_start_addr, true, NULL);
+	}
+
+	/* Put device tree in DRAM, note that riscv_load_fdt will pack fdt so we won't be able to modify it
+	 * afterwards, that's why this is the last thing we do before boot. */
+	fdt_load_addr = riscv_compute_fdt_addr(sdv3_memmap[SDV3_DRAM].base,
+                                           sdv3_memmap[SDV3_DRAM].size,
+                                           machine);
+	riscv_load_fdt(fdt_load_addr, machine->fdt);
+
+	/* load the reset vector to brom and ask it to jump to firmware/pflash and provide it with fdt/s-mode payload addr */
+	riscv_setup_rom_reset_vec(machine, &st->cpus, start_addr,
+				sdv3_memmap[SDV3_BROM].base, sdv3_memmap[SDV3_BROM].size,
+				s_mode_payload_addr, fdt_load_addr);
+
+}
+
+static void sdv3_machine_init(MachineState *machine)
+{
+	Sdv3State *st = SDV3_MACHINE(machine);
+	MemoryRegion *system_memory = get_system_memory();
+	MemoryRegion *mask_rom = g_new(MemoryRegion, 1);
+	NICInfo *nd = &nd_table[0];
+	DeviceState *dev;
+	int base_hartid = 0;
+	int hart_count = machine->smp.cpus;
+	char *plic_hart_config;
+	MemoryRegion *mr;
+
+	/* Register cpus */
+	object_initialize_child(OBJECT(machine), "cpus", &st->cpus,
+                                TYPE_RISCV_HART_ARRAY);
+        object_property_set_str(OBJECT(&st->cpus), "cpu-type",
+				machine->cpu_type, &error_abort);
+        object_property_set_int(OBJECT(&st->cpus), "hartid-base",
+				base_hartid, &error_abort);
+	object_property_set_int(OBJECT(&st->cpus), "num-harts",
+				hart_count, &error_abort);
+	sysbus_realize(SYS_BUS_DEVICE(&st->cpus), &error_fatal);
+
+	/* SiFive Test MMIO device (for reboot/halt) */
+	sifive_test_create(sdv3_memmap[SDV3_TEST].base);
+
+	/* Register CLINT */
+	riscv_aclint_swi_create(sdv3_memmap[SDV3_CLINT].base, base_hartid, hart_count, false);
+	riscv_aclint_mtimer_create(sdv3_memmap[SDV3_CLINT].base + RISCV_ACLINT_SWI_SIZE,
+				RISCV_ACLINT_DEFAULT_MTIMER_SIZE, base_hartid, hart_count,
+				RISCV_ACLINT_DEFAULT_MTIMECMP, RISCV_ACLINT_DEFAULT_MTIME,
+				SDV3_TIMEBASE_FREQ, true);
+
+	/* Register PLIC */
+	plic_hart_config = riscv_plic_hart_config_string(hart_count);
+	dev = sifive_plic_create(sdv3_memmap[SDV3_PLIC].base, plic_hart_config,
+				hart_count, base_hartid,
+				SDV3_PLIC_NUM_SOURCES, SDV3_PLIC_NUM_PRIORITIES,
+				PLIC_PRIORITY_BASE, PLIC_PENDING_BASE,
+				PLIC_ENABLE_BASE, PLIC_ENABLE_STRIDE,
+				PLIC_CONTEXT_BASE, PLIC_CONTEXT_STRIDE,
+				sdv3_memmap[SDV3_PLIC].size);
+	g_free(plic_hart_config);
+	st->plic = dev;
+
+	/* Register UART */
+	serial_mm_init(system_memory, sdv3_memmap[SDV3_UART].base, 2,
+			qdev_get_gpio_in(st->plic, SDV3_UART_IRQ), SDV3_CLOCK_FREQ,
+			serial_hd(0), DEVICE_LITTLE_ENDIAN);
+
+	/* Register emaclite */
+	qemu_check_nic_model(nd, "xlnx.xps-ethernetlite");
+	dev = qdev_new("xlnx.xps-ethernetlite");
+	qdev_set_nic_properties(dev, nd);
+	qdev_prop_set_uint32(dev, "tx-ping-pong", 1);
+	qdev_prop_set_uint32(dev, "rx-ping-pong", 1);
+	sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+	//sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, sdv3_memmap[SDV3_EMACLITE].base);
+	sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0,
+			   qdev_get_gpio_in(st->plic, SDV3_EMACLITE_IRQ));	
+	mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+	memory_region_add_subregion(system_memory, sdv3_memmap[SDV3_EMACLITE].base, mr);
+	error_report("emaclite at 0x%016lx\n", mr->addr);
+
+	/* Register pflash */
+	pflash_cfi01_legacy_drive(st->pflash, drive_get(IF_PFLASH, 0, 0));
+	dev = DEVICE(st->pflash);
+	sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+    	memory_region_add_subregion(system_memory, sdv3_memmap[SDV3_FLASH].base,
+				    sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0));
+
+	/* Register system memory */
+	memory_region_add_subregion(system_memory, sdv3_memmap[SDV3_DRAM].base, machine->ram);
+
+	/* Bootrom (QEMU's reset vector, see boot.c) */
+	memory_region_init_rom(mask_rom, NULL, "sdv3.brom", sdv3_memmap[SDV3_BROM].size, &error_fatal);
+	memory_region_add_subregion(system_memory, sdv3_memmap[SDV3_BROM].base, mask_rom);
+
+	/* load/create device tree */
+	if (machine->dtb) {
+		machine->fdt = load_device_tree(machine->dtb, &st->fdt_size);
+		if (!machine->fdt) {
+			error_report("load_device_tree() failed");
+			exit(1);
+		}
+	} else {
+		create_fdt(st);
+	}
+
+	st->machine_done.notify = sdv3_machine_done;
+	qemu_add_machine_init_done_notifier(&st->machine_done);
+}
+
+static void sdv3_machine_instance_init(Object *obj)
+{
+	Sdv3State *st = SDV3_MACHINE(obj);
+
+	/* Same as in virt.c */
+	DeviceState *dev = qdev_new(TYPE_PFLASH_CFI01);
+
+	qdev_prop_set_uint64(dev, "sector-length", PFLASH_SECTOR_SIZE);
+	qdev_prop_set_uint8(dev, "width", 4);
+	qdev_prop_set_uint8(dev, "device-width", 2);
+	qdev_prop_set_bit(dev, "big-endian", false);
+	qdev_prop_set_uint16(dev, "id0", 0x89);
+	qdev_prop_set_uint16(dev, "id1", 0x18);
+	qdev_prop_set_uint16(dev, "id2", 0x00);
+	qdev_prop_set_uint16(dev, "id3", 0x00);
+	qdev_prop_set_string(dev, "name", "sdv3.pflash");
+	qdev_prop_set_uint32(dev, "num-blocks", sdv3_memmap[SDV3_FLASH].size / PFLASH_SECTOR_SIZE);
+
+	object_property_add_child(OBJECT(st), "sdv3.pflash", OBJECT(dev));
+	object_property_add_alias(OBJECT(st), "pflash0", OBJECT(dev), "drive");
+
+	st->pflash = PFLASH_CFI01(dev);
+}
+
+static void sdv3_machine_class_init(ObjectClass *oc, void *data)
+{
+	MachineClass *mc = MACHINE_CLASS(oc);
+
+	mc->desc = "EUPILOT Prototype Simulator";
+	mc->init = sdv3_machine_init;
+	mc->default_cpu_type = TYPE_RISCV_CPU_EUPILOT;
+	mc->max_cpus = SDV3_CPUS_MAX;
+	mc->min_cpus = 1;
+	mc->default_cpus = mc->min_cpus;
+	mc->default_ram_id = "riscv.sdv3.ram";
+	mc->default_ram_size = 2 * GiB;
+}
+
+/* QEMU Glue */
+static const TypeInfo sdv3_machine_typeinfo = {
+    .name       = TYPE_RISCV_SDV3_MACHINE,
+    .parent     = TYPE_MACHINE,
+    .class_init = sdv3_machine_class_init,
+    .instance_init = sdv3_machine_instance_init,
+    .instance_size = sizeof(Sdv3State),
+};
+
+static void sdv3_machine_init_register_types(void)
+{
+    type_register_static(&sdv3_machine_typeinfo);
+}
+
+type_init(sdv3_machine_init_register_types)
diff --git a/target/riscv/cpu-qom.h b/target/riscv/cpu-qom.h
index 91b3361..1d97d95 100644
--- a/target/riscv/cpu-qom.h
+++ b/target/riscv/cpu-qom.h
@@ -42,6 +42,7 @@
 #define TYPE_RISCV_CPU_THEAD_C906       RISCV_CPU_TYPE_NAME("thead-c906")
 #define TYPE_RISCV_CPU_VEYRON_V1        RISCV_CPU_TYPE_NAME("veyron-v1")
 #define TYPE_RISCV_CPU_HOST             RISCV_CPU_TYPE_NAME("host")
+#define TYPE_RISCV_CPU_EUPILOT          RISCV_CPU_TYPE_NAME("eupilot")
 
 OBJECT_DECLARE_CPU_TYPE(RISCVCPU, RISCVCPUClass, RISCV_CPU)
 
diff --git a/target/riscv/cpu.c b/target/riscv/cpu.c
index 83c7c0c..c9931c3 100644
--- a/target/riscv/cpu.c
+++ b/target/riscv/cpu.c
@@ -535,6 +535,41 @@ static void rv64_veyron_v1_cpu_init(Object *obj)
 #endif
 }
 
+static void rv64_eupilot_cpu_init(Object *obj)
+{
+	RISCVCPU *cpu = RISCV_CPU(obj);
+	CPURISCVState *env = &cpu->env;
+	riscv_cpu_set_misa(env, MXL_RV64, RVI | RVM | RVA | RVF | RVD | RVC | RVU | RVS | RVV);
+
+#ifndef CONFIG_USER_ONLY
+	set_satp_mode_max_supported(RISCV_CPU(obj), VM_1_10_SV48);
+#endif
+
+	env->priv_ver = PRIV_VERSION_1_10_0;
+	env->vext_ver = VEXT_VERSION_1_00_0;
+
+	/* inherited from parent obj via riscv_cpu_init() */
+	cpu->cfg.ext_zifencei = true;
+	cpu->cfg.ext_zicsr = true;
+	cpu->cfg.mmu = true;
+
+	/* override defaults */
+	cpu->cfg.ext_zihintpause = false;
+	cpu->cfg.ext_zawrs = false;
+	cpu->cfg.ext_zfa = false;
+	cpu->cfg.pmp = false;
+	cpu->cfg.ext_sstc = false;
+	cpu->cfg.vlen = 128;
+	cpu->cfg.elen = 64;
+	cpu->cfg.ext_svadu = false;
+	cpu->cfg.ext_zba = false;
+	cpu->cfg.ext_zbb = false;
+	cpu->cfg.ext_zbc = false;
+	cpu->cfg.ext_zbs = false;
+	cpu->cfg.ext_zicbom = false;
+	cpu->cfg.ext_zicboz = false;
+}
+
 static void rv128_base_cpu_init(Object *obj)
 {
     if (qemu_tcg_mttcg_enabled()) {
@@ -1810,6 +1845,7 @@ static const TypeInfo riscv_cpu_type_infos[] = {
     DEFINE_CPU(TYPE_RISCV_CPU_SHAKTI_C,         rv64_sifive_u_cpu_init),
     DEFINE_CPU(TYPE_RISCV_CPU_THEAD_C906,       rv64_thead_c906_cpu_init),
     DEFINE_CPU(TYPE_RISCV_CPU_VEYRON_V1,        rv64_veyron_v1_cpu_init),
+    DEFINE_CPU(TYPE_RISCV_CPU_EUPILOT,          rv64_eupilot_cpu_init),
     DEFINE_DYNAMIC_CPU(TYPE_RISCV_CPU_BASE128,  rv128_base_cpu_init),
 #endif
 };
